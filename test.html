<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <title>WebGL test</title>
    </head>

    <body onload="start()" onresize="resize()">
      <div>
        <canvas id="container"></canvas>
      </div>

      <div id="output"></div>
    </body>

<script src="vector_math.min.js"></script>
<script>
  Vector2 = vectormath.Vector2;
  Vector3 = vectormath.Vector3;
  Vector4 = vectormath.Vector4;
  Matrix4 = vectormath.Matrix4;
</script>

<script src="webgl-utils.js"></script>
<script src="keycodes.js"></script>
<script src="Camera.js"></script>
<script src="math.js"></script>
<script src="vsQuad.js"></script>
<script src="fsTrace.js"></script>
<script src="Quad.js"></script>
<script>
var App = function(canvas, output)
{
  try {
    this.canvas = canvas;

    var opts = { alpha: false, depth: false, stencil: false, antialias: false, failIfMajorPerformanceCaveat: true };
    this.gl = WebGLUtils.setupWebGL(canvas);
    if (!this.gl) {
     return;
    }

    this.camera = new Camera();
    this.ownMouse = false;
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

lastTime = new Date();

App.prototype.update = function()
{
  if (!this.gl) {
    return;
  }
  try {
    var time = new Date();
    var dt = (time - lastTime) / 1000.0;
    lastTime = time;
    this.camera.update(dt);

    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

    this.gl.clearColor(0.6, 0.0, 0.3, 1.0);
    this.gl.clearDepth(1.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    this.quad.draw(this.gl, this.camera, this.canvas.width, this.canvas.height, this.camera.framesSinceLastAction);

    window.requestAnimFrame(function (){ app.update();});
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

App.prototype.clicked = function(event) {
  try {
    if (this.canvas.requestPointerLock) {
      this.canvas.requestPointerLock();
    } else if (this.canvas.mozRequestPointerLock) {
      this.canvas.mozRequestPointerLock();
    }
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

App.prototype.pointerLockChange = function(event) {
  try {
    this.ownMouse = (this.canvas == document.pointerLockElement) || (this.canvas == document.mozPointerLockElement);
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

App.prototype.keyDown = function(event) {
  try {
    this.quad.keydown(event.keyCode);
    if (this.ownMouse)
      this.camera.keydown(event.keyCode);
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

App.prototype.keyUp = function(event) {
  try {
    if (this.ownMouse)
      this.camera.keyup(event.keyCode);
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

App.prototype.mouseMove = function(event) {
  try {
    if (!this.ownMouse)
      return;
    this.camera.mouseDelta.add( new Vector2(event.movementX, event.movementY));
    event.preventDefault();
  } catch(err) {
    document.getElementById("output").innerHTML = err;
  }
}

// function start() {
  var canvas = document.getElementById("container");
  var output = document.getElementById("output");
  app = new App(canvas, output);

  canvas.width = 1024;
  canvas.height = 1024;
  app.gl.viewport(0, 0, canvas.width, canvas.height);
  app.gl.clearColor(0.6, 0.0, 0.3, 1.0);
  app.gl.clearDepth(1.0);
  app.gl.clear(app.gl.COLOR_BUFFER_BIT | app.gl.DEPTH_BUFFER_BIT);
  app.quad = new Quad(app.gl, canvas.width, canvas.height);
  app.quad.draw(app.gl, app.camera, canvas.width, canvas.height, 0);

  // document.addEventListener('pointerlockchange', function(event){  app.pointerLockChange(event); }, false);
  // document.addEventListener('mozpointerlockchange', function(event){  app.pointerLockChange(event); }, false);
  // canvas.onclick = function(event) { app.clicked(event); } ;
  // document.onkeydown = function(event){  app.keyDown(event); };
  // document.onkeyup = function(event){  app.keyUp(event); };
  // document.onmousemove = function(event){  app.mouseMove(event); };

  window.requestAnimFrame(function (){ app.update();});
// }


// function resize()
// {
//   document.getElementById("output").innerHTML = "resized" + this.canvas.width + "x" + this.canvas.height;
//   app.quad = new Quad(app.gl, this.canvas.width, this.canvas.height);
// }
</script>


</html>
